# Исправления проекта simpy-rs

## Исправленные ошибки

### 1. Проблемы многопоточности с Lua (31 ошибка компиляции)

**Проблема:** `mlua::Lua` не реализует `Send + Sync`, что вызывало ошибки при попытке использовать его в `tokio::spawn` и других многопоточных контекстах.

**Решение:**
- Убрали использование `tokio::spawn` для работы с Lua процессами
- Изменили архитектуру: добавили очередь возобновления процессов (`resume_queue`)
- Процессы теперь возобновляются в основном потоке симуляции через `process_resume_queue()`
- Используем `tokio::task::block_in_place` для синхронного добавления в очередь из замыканий событий

### 2. Ошибка заимствования в `src/lua/process.rs`

**Проблема:** Попытка переместить `lua` после заимствования через `globals`.

**Решение:**
- Обернули получение функции и создание registry_key в блок `{}`
- Это освобождает заимствование `globals` до перемещения `lua` в структуру

### 3. Неиспользуемый импорт `ProcessState`

**Проблема:** Warning о неиспользуемом импорте в `src/simulator.rs`.

**Решение:**
- Удалили `ProcessState` из списка импортов

### 4. Ошибка с перемещением `engine` после `drop`

**Проблема:** В `process_lua_messages` переменная `engine` использовалась после `drop(engine)`.

**Решение:**
- Реструктурировали код: получаем сообщения и сразу освобождаем `engine`
- Для каждого сообщения заново блокируем `engine` при необходимости

## Реализованные функции

### 1. Функция `spawn()`

Полностью реализована возможность динамического создания процессов:

- `LuaEngine` теперь хранит загруженные скрипты в `HashMap<String, String>`
- Добавлен метод `spawn_process()` для создания новых процессов из существующих скриптов
- В симуляторе обрабатывается сообщение `ProcessMessage::Spawn`
- Новые процессы получают текущее время симуляции и сразу запускаются

### 2. Функция `now()`

Добавлена возможность получать текущее время симуляции из Lua:

- Время хранится в глобальной переменной `_sim_time`
- `LuaEngine.update_time()` обновляет время во всех процессах
- Симулятор обновляет время в начале каждой итерации цикла

### 3. Очистка завершенных процессов

- Добавлен метод `LuaEngine.cleanup_finished()`
- Процессы не удаляются сразу при получении `Finished`, а только после обработки всех их сообщений
- Это предотвращает ошибки "Process not found"

## Известные ограничения

### Проблема с приостановкой процессов

**Текущее состояние:** Lua процессы выполняются полностью за один вызов `resume()`, не приостанавливаясь на `wait()`.

**Причина:** 
- Lua не позволяет делать `yield` из C-функций ("yield across a C-call boundary")
- Функция `wait()` реализована как Rust функция, вызываемая из Lua
- Попытка вызвать `coroutine.yield()` из Rust функции приводит к ошибке

**Возможные решения:**
1. Использовать Lua-обертки вместо прямых Rust функций
2. Реализовать кооперативную многозадачность на уровне Lua скриптов
3. Использовать другую библиотеку для скриптинга (например, Rhai)

## Статус проекта

✅ Проект компилируется без ошибок  
✅ Функция `spawn()` работает  
✅ Функция `now()` работает  
✅ Ресурсы работают  
⚠️  Процессы не приостанавливаются на `wait()` (выполняются мгновенно)  

## Примеры

- `test_simple` - работает ✅
- `test_spawn` - работает, но процессы выполняются мгновенно ⚠️
- `bank_simulation` - работает, но без реальных задержек ⚠️
- `bank_simple` - создан как альтернатива ✅

## Следующие шаги

Для полноценной работы симуляции нужно решить проблему с приостановкой процессов. Рекомендуемый подход - переписать Lua API так, чтобы `wait()` была Lua-функцией, которая вызывает `coroutine.yield()`, а Rust функция только регистрирует намерение ждать.
